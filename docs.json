{
  "/NTgCalls/Advanced Methods/Add Incoming Video.xml": {
    "title": "Add Incoming Video",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows to notify the library that an incoming video stream is available.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\nendpoint = ...\nssrc_groups = ...\n\nawait app.add_incoming_video(\n    -1001185324811,\n    endpoint,\n    ssrc_groups,\n)"
    },
    "details": {
      "signature": "async NTgCalls.add_incoming_video() -> int",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "endpoint",
              "type": "str",
              "description": " Endpoint ID",
              "source_config": null,
              "value": null
            },
            {
              "name": "ssrc_groups",
              "type": "list[ntgcalls.SsrcGroup]",
              "description": " SSRC groups for the video stream.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/Add Incoming Video"
  },
  "/NTgCalls/Advanced Methods/Get State.xml": {
    "title": "Get State",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows retrieving GroupCall MTProto Configurations for\n      EditGroupCallParticipant.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nstate = app.get_state(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "get_state() -> ntgcalls.MediaState",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/Get State"
  },
  "/NTgCalls/Advanced Methods/Remove Incoming Video.xml": {
    "title": "Remove Incoming Video",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows to notify the library that an incoming video stream is no longer available.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\nendpoint = ...\n\nawait app.remove_incoming_video(\n    -1001185324811,\n    endpoint,\n)"
    },
    "details": {
      "signature": "async NTgCalls.remove_incoming_video()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "endpoint",
              "type": "str",
              "description": " Endpoint ID",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/Remove Incoming Video"
  },
  "/NTgCalls/Advanced Methods/Send External Frame.xml": {
    "title": "Send External Frame",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows sending an external video frame to the WebRTC connection.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\nfrom ntgcalls import StreamDevice\nfrom ntgcalls import FrameData\nfrom datetime import datetime\n...\n\napp = NTgCalls()\n...\npcm16_le_data = ...\n\nawait app.send_external_frame(\n    -1001185324811,\n    StreamDevice.MICROPHONE,\n    pcm16_le_data,\n    FrameData(\n        int(datetime.now().timestamp()),\n        0,\n        0,\n        0,\n    )\n)"
    },
    "details": {
      "signature": "async NTgCalls.send_external_frame()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "device",
              "type": "ntgcalls.StreamDevice",
              "description": " Device Kind",
              "source_config": null,
              "value": null
            },
            {
              "name": "frame",
              "type": "bytes",
              "description": " Frame buffer",
              "source_config": null,
              "value": null
            },
            {
              "name": "frame_data",
              "type": "ntgcalls.FrameData",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/Send External Frame"
  },
  "/NTgCalls/Advanced Methods/Send Signaling Data.xml": {
    "title": "Send Signaling Data",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows sending signaling data to the WebRTC connection.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.send_signaling_data(\n    -1001185324811,\n    \"data\",\n)"
    },
    "details": {
      "signature": "async NTgCalls.send_signaling_data()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "data",
              "type": "bytes",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/Send Signaling Data"
  },
  "/NTgCalls/Advanced Methods/ntg_add_incoming_video.xml": {
    "title": "ntg_add_incoming_video",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows to notify the library that an incoming video stream is available.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    char* endpoint = ...; // Obtain the endpoint of the incoming video\n    ntg_ssrc_group_struct* ssrcGroups = ...; // Obtain the SSRC groups of the incoming video\n    int size = ...; // Obtain the size of the SSRC groups array\n    uint32_t ssrc_buffer;\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_add_incoming_video(uid, chatID, endpoint, ssrcGroups, &ssrc_buffer, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_add_incoming_video()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "char* endpoint",
              "type": null,
              "description": " Endpoint ID",
              "source_config": null,
              "value": null
            },
            {
              "name": "ntg_ssrc_group_struct* ssrcGroups",
              "type": null,
              "description": " SSRC groups for the video stream.",
              "source_config": null,
              "value": null
            },
            {
              "name": "int size",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "uint32_t* buffer",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_add_incoming_video"
  },
  "/NTgCalls/Advanced Methods/ntg_calls.xml": {
    "title": "ntg_calls",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        This function returns a list of ",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int size = ...  ; // Get the size of the call list\n    ntg_call_struct buffer[size];\n    // Initialize the async struct\n    ntg_async_struct future;\n    int result = ntg_calls(uid, buffer, size, &future);\n    // Wait for the async operation to complete\n    for (int i = 0; i < result; i++) {\n        printf(\"Group Call %d:\\n\", i + 1);\n        printf(\"  Chat ID: %lld\\n\", buffer[i].chatId);\n        printf(\"  Status: %d\\n\", buffer[i].status);\n    }\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_calls()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_call_struct* buffer",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "ARG_BUF_SIZE]",
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_BUF_SIZE",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "SMALL_BUFF_EXCEPTION]",
              "description": "",
              "source_config": "SMALL_BUFF_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_calls"
  },
  "/NTgCalls/Advanced Methods/ntg_calls_count.xml": {
    "title": "ntg_calls_count",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        This function returns the number of active group calls that NTgCalls is connected to.\n    ",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    int count = 0;\n    // Initialize the async struct\n    ntg_async_struct future;\n    int result = ntg_calls_count(uid, &count, &future);\n    // Wait for the async operation to complete\n    printf(\"Number of active group calls: %d\\n\", count);\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_calls_count()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "int* count",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_calls_count"
  },
  "/NTgCalls/Advanced Methods/ntg_cpu_usage.xml": {
    "title": "ntg_cpu_usage",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "Get an estimate of the CPU usage of the current process.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    double buffer;\n    // Initialize the async struct\n    ntg_async_struct future;\n    int64_t usage = ntg_cpu_usage(uid, &buffer, &future);\n    // Wait for the async operation to complete and use\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_cpu_usage()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "double* cpuUsage",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_cpu_usage"
  },
  "/NTgCalls/Advanced Methods/ntg_enable_g_lib_loop.xml": {
    "title": "ntg_enable_g_lib_loop",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "Enable the GLib main loop to allow the library to use it for PipeWire on OSes that uses Wayland.",
    "example": {
      "language": "cpp",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    ...\n    ntg_enable_g_lib_loop(true);\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_enable_g_lib_loop()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "bool enable",
              "type": null,
              "description": " Enable or disable the GLib main loop.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_enable_g_lib_loop"
  },
  "/NTgCalls/Advanced Methods/ntg_enable_h264_encoder.xml": {
    "title": "ntg_enable_h264_encoder",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {
      "language": "cpp",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    ...\n    ntg_enable_h264_encoder(true);\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_enable_h264_encoder()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "bool enable",
              "type": null,
              "description": " Enable or disable the H264 encoder.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_enable_h264_encoder"
  },
  "/NTgCalls/Advanced Methods/ntg_get_media_devices.xml": {
    "title": "ntg_get_media_devices",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting all the available media devices, such as microphones and cameras.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    ...\n    ntg_media_devices_struct devices;\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_get_media_devices(&devices, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_get_media_devices()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "ntg_media_devices_struct* buffer",
              "type": null,
              "description": " Media devices available for streaming. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_get_media_devices"
  },
  "/NTgCalls/Advanced Methods/ntg_get_protocol.xml": {
    "title": "ntg_get_protocol",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting the protocol for a Private Call connection with the output params for Telegram constructor\n      PhoneCallProtocol.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_protocol_struct buffer;\n    ntg_get_protocol(uid, chatID, &buffer);\n    ...\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_get_protocol()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_protocol_struct* protocol",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_get_protocol"
  },
  "/NTgCalls/Advanced Methods/ntg_get_state.xml": {
    "title": "ntg_get_state",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows retrieving GroupCall MTProto Configurations for\n      EditGroupCallParticipant.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_media_state_struct buffer;\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_get_state(uid, chatID, &buffer, &future);\n    // Wait for the async operation to complete and use\n    // the buffer for EditGroupCallParticipant\n    ...\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_get_state()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_media_state_struct* mediaState",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_get_state"
  },
  "/NTgCalls/Advanced Methods/ntg_remove_incoming_video.xml": {
    "title": "ntg_remove_incoming_video",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows to notify the library that an incoming video stream is no longer available.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    char* endpoint = ...; // Obtain the endpoint of the incoming video\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_remove_incoming_video(uid, chatID, endpoint, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_remove_incoming_video()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "char* endpoint",
              "type": null,
              "description": " Endpoint ID ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_remove_incoming_video"
  },
  "/NTgCalls/Advanced Methods/ntg_send_external_frame.xml": {
    "title": "ntg_send_external_frame",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows sending an external video frame to the WebRTC connection.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    uint8_t* pcm16_le_data = ...; // Obtain the PCM16 LE data\n    int size = ...; // Obtain the size of the PCM16 LE data\n    ntg_frame_data frame_data = {\n        .timestamp = ..., // Obtain the timestamp\n        .flags = 0,\n        .rotation = 0,\n        .layer = 0,\n    };\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_send_external_frame(uid, chatID, NTG_STREAM_DEVICE_MICROPHONE, pcm16_le_data, size, &frame_data, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_send_external_frame()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_stream_device_enum device",
              "type": null,
              "description": " Device Kind",
              "source_config": null,
              "value": null
            },
            {
              "name": "uint8_t* frame",
              "type": null,
              "description": " Frame buffer",
              "source_config": null,
              "value": null
            },
            {
              "name": "int size",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "ntg_frame_data_struct* frame_data",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_send_external_frame"
  },
  "/NTgCalls/Advanced Methods/ntg_send_signaling_data.xml": {
    "title": "ntg_send_signaling_data",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows sending signaling data to the WebRTC connection.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    uint8_t* buffer = ...; // Obtain the signaling data\n    int size = ...; // Obtain the size of the signaling data\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_send_signaling_data(uid, chatID, buffer, size, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_send_signaling_data()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "uint8_t* data",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "int size",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Advanced Methods/ntg_send_signaling_data"
  },
  "/NTgCalls/Available Enums/ConnectionKind.xml": {
    "title": "ConnectionKind",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Kind of connection.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.ConnectionKind",
      "members": [
        {
          "name": "NORMAL",
          "type": null,
          "description": " Normal connection for the camera and microphone.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "PRESENTATION",
          "type": null,
          "description": " Presentation connection for sharing the screen and system audio.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ConnectionKind"
  },
  "/NTgCalls/Available Enums/ConnectionState.xml": {
    "title": "ConnectionState",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of connection state values.",
    "example": {},
    "details": {
      "signature": "class ConnectionState",
      "members": [
        {
          "name": "CONNECTING",
          "type": null,
          "description": " Indicates that the connection is in the process of being established.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "CONNECTED",
          "type": null,
          "description": " Indicates that the connection has been established.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "FAILED",
          "type": null,
          "description": " Indicates that the connection has failed.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "TIMEOUT",
          "type": null,
          "description": " Indicates that the connection has timed out.",
          "source_config": null,
          "value": "3"
        },
        {
          "name": "CLOSED",
          "type": null,
          "description": " Indicates that the connection has been closed.",
          "source_config": null,
          "value": "4"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ConnectionState"
  },
  "/NTgCalls/Available Enums/MediaSource.xml": {
    "title": "MediaSource",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of input modes for audio and video streams.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.MediaSource",
      "members": [
        {
          "name": "FILE",
          "type": null,
          "description": " Input mode using a file source.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "SHELL",
          "type": null,
          "description": " Input mode using a shell command.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "FFMPEG",
          "type": null,
          "description": " Input mode using FFmpeg.",
          "source_config": null,
          "value": "4"
        },
        {
          "name": "DEVICE",
          "type": null,
          "description": " Input mode using a device source.",
          "source_config": null,
          "value": "8"
        },
        {
          "name": "DESKTOP",
          "type": null,
          "description": " Input mode using a desktop source.",
          "source_config": null,
          "value": "16"
        },
        {
          "name": "EXTERNAL",
          "type": null,
          "description": " Input mode using an external source.",
          "source_config": null,
          "value": "32"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/MediaSource"
  },
  "/NTgCalls/Available Enums/StreamDevice.xml": {
    "title": "StreamDevice",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream device values.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.StreamDevice",
      "members": [
        {
          "name": "MICROPHONE",
          "type": null,
          "description": " Input mode using a microphone source.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "SPEAKER",
          "type": null,
          "description": " Input mode using a speaker source.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "CAMERA",
          "type": null,
          "description": " Input mode using a camera source.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "SCREEN",
          "type": null,
          "description": " Input mode using a screen source.",
          "source_config": null,
          "value": "3"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/StreamDevice"
  },
  "/NTgCalls/Available Enums/StreamMode.xml": {
    "title": "StreamMode",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Stream direction for the stream.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.StreamMode",
      "members": [
        {
          "name": "CAPTURE",
          "type": null,
          "description": " Direction for sending the stream.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "PLAYBACK",
          "type": null,
          "description": " Direction for receiving the stream.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/StreamMode"
  },
  "/NTgCalls/Available Enums/StreamStatus.xml": {
    "title": "StreamStatus",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream status values.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.StreamStatus",
      "members": [
        {
          "name": "PLAYING",
          "type": null,
          "description": " Indicates that the stream is currently playing.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "PAUSED",
          "type": null,
          "description": " Indicates that the stream is currently paused.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "IDLING",
          "type": null,
          "description": " Indicates that the stream is currently idling (neither playing nor paused).",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/StreamStatus"
  },
  "/NTgCalls/Available Enums/StreamType.xml": {
    "title": "StreamType",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream type values.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.StreamType",
      "members": [
        {
          "name": "AUDIO",
          "type": null,
          "description": " Indicates that the stream type is audio.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "VIDEO",
          "type": null,
          "description": " Indicates that the stream type is video.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/StreamType"
  },
  "/NTgCalls/Available Enums/ntg_connection_kind_enum.xml": {
    "title": "ntg_connection_kind_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Kind of connection.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_connection_kind_enum",
      "members": [
        {
          "name": "NTG_KIND_NORMAL",
          "type": null,
          "description": " Normal connection for the camera and microphone.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_KIND_PRESENTATION",
          "type": null,
          "description": " Presentation connection for sharing the screen and system audio.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_connection_kind_enum"
  },
  "/NTgCalls/Available Enums/ntg_connection_state_enum.xml": {
    "title": "ntg_connection_state_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of connection state values.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_connection_state_enum",
      "members": [
        {
          "name": "NTG_STATE_CONNECTING",
          "type": null,
          "description": " Indicates that the connection is in the process of being established.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_STATE_CONNECTED",
          "type": null,
          "description": " Indicates that the connection has been established.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_STATE_FAILED",
          "type": null,
          "description": " Indicates that the connection has failed.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "NTG_STATE_TIMEOUT",
          "type": null,
          "description": " Indicates that the connection has timed out.",
          "source_config": null,
          "value": "3"
        },
        {
          "name": "NTG_STATE_CLOSED",
          "type": null,
          "description": " Indicates that the connection has been closed.",
          "source_config": null,
          "value": "4"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_connection_state_enum"
  },
  "/NTgCalls/Available Enums/ntg_log_level_enum.xml": {
    "title": "ntg_log_level_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Log level.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_log_level_enum",
      "members": [
        {
          "name": "NTG_LOG_DEBUG",
          "type": null,
          "description": " Debug log level.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_LOG_INFO",
          "type": null,
          "description": " Info log level.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "NTG_LOG_WARNING",
          "type": null,
          "description": " Warning log level.",
          "source_config": null,
          "value": "4"
        },
        {
          "name": "NTG_LOG_ERROR",
          "type": null,
          "description": " Error log level.",
          "source_config": null,
          "value": "8"
        },
        {
          "name": "NTG_LOG_UNKNOWN",
          "type": null,
          "description": " Unknown log level.",
          "source_config": null,
          "value": "-1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_log_level_enum"
  },
  "/NTgCalls/Available Enums/ntg_log_source_enum.xml": {
    "title": "ntg_log_source_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Log source.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_log_source_enum",
      "members": [
        {
          "name": "NTG_LOG_WEBRTC",
          "type": null,
          "description": " WebRTC log level.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_LOG_SELF",
          "type": null,
          "description": " NTgCalls log level.",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_log_source_enum"
  },
  "/NTgCalls/Available Enums/ntg_media_source_enum.xml": {
    "title": "ntg_media_source_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of input modes for audio and video streams.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_media_source_enum",
      "members": [
        {
          "name": "NTG_FILE",
          "type": null,
          "description": " Input mode using a file source.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_SHELL",
          "type": null,
          "description": " Input mode using a shell command.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "NTG_FFMPEG",
          "type": null,
          "description": " Input mode using FFmpeg.",
          "source_config": null,
          "value": "4"
        },
        {
          "name": "NTG_DEVICE",
          "type": null,
          "description": " Input mode using a device source.",
          "source_config": null,
          "value": "8"
        },
        {
          "name": "NTG_DESKTOP",
          "type": null,
          "description": " Input mode using a desktop source.",
          "source_config": null,
          "value": "16"
        },
        {
          "name": "NTG_EXTERNAL",
          "type": null,
          "description": " Input mode using an external source.",
          "source_config": null,
          "value": "32"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_media_source_enum"
  },
  "/NTgCalls/Available Enums/ntg_stream_device_enum.xml": {
    "title": "ntg_stream_device_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream device values.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_stream_device_enum",
      "members": [
        {
          "name": "NTG_STREAM_MICROPHONE",
          "type": null,
          "description": " Input mode using a microphone source.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_STREAM_SPEAKER",
          "type": null,
          "description": " Input mode using a speaker source.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_STREAM_CAMERA",
          "type": null,
          "description": " Input mode using a camera source.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "NTG_STREAM_SCREEN",
          "type": null,
          "description": " Input mode using a screen source.",
          "source_config": null,
          "value": "3"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_stream_device_enum"
  },
  "/NTgCalls/Available Enums/ntg_stream_mode_enum.xml": {
    "title": "ntg_stream_mode_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Stream direction for the stream.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_stream_mode_enum",
      "members": [
        {
          "name": "NTG_STREAM_CAPTURE",
          "type": null,
          "description": " Direction for sending the stream.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_STREAM_PLAYBACK",
          "type": null,
          "description": " Direction for receiving the stream.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_stream_mode_enum"
  },
  "/NTgCalls/Available Enums/ntg_stream_status_enum.xml": {
    "title": "ntg_stream_status_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream status values.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_stream_status_enum",
      "members": [
        {
          "name": "NTG_PLAYING",
          "type": null,
          "description": " Indicates that the stream is currently playing.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_PAUSED",
          "type": null,
          "description": " Indicates that the stream is currently paused.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "NTG_IDLING",
          "type": null,
          "description": " Indicates that the stream is currently idling (neither playing nor paused).",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_stream_status_enum"
  },
  "/NTgCalls/Available Enums/ntg_stream_type_enum.xml": {
    "title": "ntg_stream_type_enum",
    "lib": "NTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream type values.",
    "example": {},
    "details": {
      "signature": "typedef enum ntg_stream_type_enum",
      "members": [
        {
          "name": "NTG_STREAM_AUDIO",
          "type": null,
          "description": " Indicates that the stream type is audio.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "NTG_STREAM_VIDEO",
          "type": null,
          "description": " Indicates that the stream type is video.",
          "source_config": null,
          "value": "1"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Enums/ntg_stream_type_enum"
  },
  "/NTgCalls/Available Structs/ntg_audio_description_struct.xml": {
    "title": "ntg_audio_description_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_audio_description_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_audio_description_struct"
  },
  "/NTgCalls/Available Structs/ntg_auth_params_struct.xml": {
    "title": "ntg_auth_params_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_auth_params_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_auth_params_struct"
  },
  "/NTgCalls/Available Structs/ntg_call_info_struct.xml": {
    "title": "ntg_call_info_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_call_info_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_call_info_struct"
  },
  "/NTgCalls/Available Structs/ntg_device_info_struct.xml": {
    "title": "ntg_device_info_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_device_info_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_device_info_struct"
  },
  "/NTgCalls/Available Structs/ntg_dh_config_struct.xml": {
    "title": "ntg_dh_config_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_dh_config_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_dh_config_struct"
  },
  "/NTgCalls/Available Structs/ntg_frame_data_struct.xml": {
    "title": "ntg_frame_data_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_frame_data_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_frame_data_struct"
  },
  "/NTgCalls/Available Structs/ntg_frame_struct.xml": {
    "title": "ntg_frame_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_frame_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_frame_struct"
  },
  "/NTgCalls/Available Structs/ntg_log_message_struct.xml": {
    "title": "ntg_log_message_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_log_message_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_log_message_struct"
  },
  "/NTgCalls/Available Structs/ntg_media_description_struct.xml": {
    "title": "ntg_media_description_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_media_description_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_media_description_struct"
  },
  "/NTgCalls/Available Structs/ntg_media_devices_struct.xml": {
    "title": "ntg_media_devices_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_media_devices_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_media_devices_struct"
  },
  "/NTgCalls/Available Structs/ntg_media_state_struct.xml": {
    "title": "ntg_media_state_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_media_state_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_media_state_struct"
  },
  "/NTgCalls/Available Structs/ntg_network_info_struct.xml": {
    "title": "ntg_network_info_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_network_info_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_network_info_struct"
  },
  "/NTgCalls/Available Structs/ntg_protocol_struct.xml": {
    "title": "ntg_protocol_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_protocol_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_protocol_struct"
  },
  "/NTgCalls/Available Structs/ntg_remote_source_struct.xml": {
    "title": "ntg_remote_source_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_remote_source_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_remote_source_struct"
  },
  "/NTgCalls/Available Structs/ntg_rtc_server_struct.xml": {
    "title": "ntg_rtc_server_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_rtc_server_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_rtc_server_struct"
  },
  "/NTgCalls/Available Structs/ntg_ssrc_group_struct.xml": {
    "title": "ntg_ssrc_group_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_ssrc_group_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_ssrc_group_struct"
  },
  "/NTgCalls/Available Structs/ntg_video_description_struct.xml": {
    "title": "ntg_video_description_struct",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "typedef struct ntg_video_description_struct"
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Structs/ntg_video_description_struct"
  },
  "/NTgCalls/Available Types/AudioDescription.xml": {
    "title": "AudioDescription",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Streams Audio Configuration input_mode: ntgcalls.MediaSource\nThe input mode for audio or video. Audio sample rate (0-96000, max allowed by PCM16L). Audio channel count (1-2, max allowed by PCM16L). input: str\nThe input media source.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.AudioDescription",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/AudioDescription"
  },
  "/NTgCalls/Available Types/AuthParams.xml": {
    "title": "AuthParams",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Authentication parameters for the connection. Parameter for key exchange. Fingerprint for the connection.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.AuthParams",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/AuthParams"
  },
  "/NTgCalls/Available Types/CallInfo.xml": {
    "title": "MediaInfo",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Call Descriptor for a Group Call or Private Call. Playback stream status. Capture stream status.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.CallInfo",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/CallInfo"
  },
  "/NTgCalls/Available Types/DeviceInfo.xml": {
    "title": "DeviceInfo",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Device Information. Device name. Device metadata, such as the device ID.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.DeviceInfo",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/DeviceInfo"
  },
  "/NTgCalls/Available Types/DhConfig.xml": {
    "title": "DhConfig",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Diffie-Hellman configuration for key exchange. New value prime, see Wikipedia. New value primitive root, see Wikipedia. Random sequence of bytes of assigned length.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.DhConfig",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/DhConfig"
  },
  "/NTgCalls/Available Types/Frame.xml": {
    "title": "Frame",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Frame descriptor for the media stream. SSRC of the frame. Frame buffer Frame data for the media stream.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.Frame",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/Frame"
  },
  "/NTgCalls/Available Types/FrameData.xml": {
    "title": "FrameData",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Frame data for the media stream. Absolute capture timestamp in milliseconds. Rotation of the video frame. Width of the video frame. Height of the video frame.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.FrameData",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/FrameData"
  },
  "/NTgCalls/Available Types/MediaDescription.xml": {
    "title": "MediaDescription",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Media Configuration for the Stream. Microphone configuration for the stream. Speaker configuration for the stream. Camera configuration for the stream. Screen configuration for the stream.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.MediaDescription",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/MediaDescription"
  },
  "/NTgCalls/Available Types/MediaDevices.xml": {
    "title": "Media Devices",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Media devices available for streaming. List of available microphones. List of available speakers. List of available cameras. List of available screens.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.MediaDevices",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/MediaDevices"
  },
  "/NTgCalls/Available Types/MediaState.xml": {
    "title": "MediaState",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "GroupCall MTProto Configurations. Indicates whether the media stream is muted. Indicates whether the video stream is paused. Indicates whether the video stream is stopped.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.MediaState",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/MediaState"
  },
  "/NTgCalls/Available Types/NetworkInfo.xml": {
    "title": "NetworkInfo",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Network status for the call. Connection state for the call. Kind of connection.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.NetworkInfo",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/NetworkInfo"
  },
  "/NTgCalls/Available Types/Protocol.xml": {
    "title": "Protocol",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Protocol for a Private Call connection. Minimum layer for remote connection. Maximum layer for remote connection. Whether to allow P2P connection to the other participant. Whether to allow connection to the other participants through the reflector servers. When using RequestCall and AcceptCall,\n        specify all library versions supported by the client.\n        The server will merge and choose the best library version supported by both peers, returning only the best\n        value in the result of the call's AcceptCall and in the PhoneCallAccepted update received by the caller.",
    "example": {},
    "details": {
      "signature": "class Protocol",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/Protocol"
  },
  "/NTgCalls/Available Types/RTCServer.xml": {
    "title": "RTCServer",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Identifies an endpoint that can be used to connect to the other user in a phone call. Endpoint ID IPv4 address of endpoint IPv6 address of endpoint Username of endpoint Password of endpoint Port ID Whether the endpoint is a TURN server Whether the endpoint is a STUN server Whether TCP should be used Our peer tag",
    "example": {},
    "details": {
      "signature": "class ntgcalls.RTCServer",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/RTCServer"
  },
  "/NTgCalls/Available Types/RemoteSource.xml": {
    "title": "RemoteSource",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Remote source for the call. SSRC of the frame. Streams Status. Streams Device.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.RemoteSource",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/RemoteSource"
  },
  "/NTgCalls/Available Types/SsrcGroup.xml": {
    "title": "SsrcGroup",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "SSRC Group with the SSRCs of the video stream and the semantics. Enumeration of SSRC group semantics values. SSRC Group.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.SsrcGroup",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/SsrcGroup"
  },
  "/NTgCalls/Available Types/VideoDescription.xml": {
    "title": "VideoDescription",
    "lib": "NTgCalls",
    "kind": "type",
    "description": "Streams Video Configuration input_mode: ntgcalls.MediaSource\nThe input mode for audio or video. width: int\nVideo width in pixels.\nheight: int\nVideo height in pixels. Frames per second (FPS) for video playback. input: str\nThe input media source.",
    "example": {},
    "details": {
      "signature": "class ntgcalls.VideoDescription",
      "members": []
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Available Types/VideoDescription"
  },
  "/NTgCalls/Basic Methods/Connect P2P.xml": {
    "title": "Connect P2P",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows connecting to a Private Call with the output params from Telegram method\n      ConfirmCall when is an outgoing call or PhoneCall when is an incoming call.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\nrtc_servers = ... # Obtain the RTC servers\ndh_config = ... # Obtain the DH configuration\nversions = ... # Obtain the library versions\np2p_allowed = ... # Obtain whether P2P is allowed\nawait app.connect_p2p(\n    -1001185324811,\n    rtc_servers,\n    versions,\n    p2p_allowed\n)"
    },
    "details": {
      "signature": "async NTgCalls.connect_p2p()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "rtc_servers",
              "type": "list[ntgcalls.RTCServer]",
              "description": " List of endpoints the user can connect to exchange call data.",
              "source_config": null,
              "value": null
            },
            {
              "name": "versions",
              "type": "list[str]",
              "description": " When using RequestCall and AcceptCall,\n        specify all library versions supported by the client.\n        The server will merge and choose the best library version supported by both peers, returning only the best\n        value in the result of the call's AcceptCall and in the PhoneCallAccepted update received by the caller.",
              "source_config": null,
              "value": null
            },
            {
              "name": "p2p_allowed",
              "type": "bool",
              "description": " Whether to allow P2P connection to the other participant.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionError\nA connection with the specified ID is already established or does not exist. exception ntgcalls.CryptoError",
              "source_config": "P2P_CONN_ERROR",
              "value": null
            },
            {
              "name": "exception ntgcalls.SignalingError",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "exception ntgcalls.SignalingUnsupported",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Connect P2P"
  },
  "/NTgCalls/Basic Methods/Connect.xml": {
    "title": "Connect",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows connecting to Telegram Group Calls with the output params from Telegram method\n      JoinGroupCall.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\ntg_params = ...\n\nawait app.connect(\n    -1001185324811,\n    tg_params,\n    False,\n)"
    },
    "details": {
      "signature": "async NTgCalls.connect()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "params",
              "type": "str",
              "description": " Connection params obtained from Telegram.",
              "source_config": null,
              "value": null
            },
            {
              "name": "is_presentation",
              "type": "bool",
              "description": " Whether the connection is for a presentation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found. exception ntgcalls.TelegramServerError\nThis error occurs when the connection between Telegram and the WebRTC service fails.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "RTMP_EXCEPTION]",
              "description": " exception ntgcalls.TransportParseException\nThis error occurs when attempting to send invalid Transports.",
              "source_config": "RTMP_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Connect"
  },
  "/NTgCalls/Basic Methods/Create Call.xml": {
    "title": "Create Call",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting connection params for Telegram WebRTC connection.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n\nparams = await app.create_call(\n    -1001185324811,\n    MediaDescription(\n        AudioDescription(\n            input_mode=InputMode.File,\n            input=\"audio.pcm\",\n            sample_rate=96000,\n            bits_per_sample=16,\n            channel_count=2,\n        ),\n    )\n)"
    },
    "details": {
      "signature": "async NTgCalls.create_call() -> str",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "media",
              "type": "ntgcalls.MediaDescription",
              "description": "Media parameters of the stream.",
              "source_config": "ARG_STREAM_PARAMS",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "exception ntgcalls.ConnectionError",
              "type": null,
              "description": " exception ntgcalls.InvalidParams\nThis error occurs when attempting to send an invalid MediaSource.\nexception ntgcalls.FileError\nThe specified file does not exist.\nexception ntgcalls.ShellError\nError while executing the shell script.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Create Call"
  },
  "/NTgCalls/Basic Methods/Create P2P Call.xml": {
    "title": "Create P2P Call",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows creating a Private Call connection that can be used to exchange keys and connect",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\napp = NTgCalls()\n...\n\nawait app.create_p2p_call(\n    -1001185324811,\n    MediaDescription(\n        AudioDescription(\n            input_mode=InputMode.File,\n            input=\"audio.pcm\",\n            sample_rate=96000,\n            bits_per_sample=16,\n            channel_count=2,\n        ),\n    )\n)"
    },
    "details": {
      "signature": "async NTgCalls.create_p2p_call()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "media",
              "type": "ntgcalls.MediaDescription",
              "description": "Media parameters of the stream.",
              "source_config": "ARG_STREAM_PARAMS",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionError\nA connection with the specified ID is already established or does not exist. exception ntgcalls.InvalidParams\nThis error occurs when attempting to send an invalid MediaSource.\nexception ntgcalls.FileError\nThe specified file does not exist.\nexception ntgcalls.ShellError\nError while executing the shell script.",
              "source_config": "P2P_CONN_ERROR",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Create P2P Call"
  },
  "/NTgCalls/Basic Methods/Exchange Keys.xml": {
    "title": "Exchange Keys",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows exchanging keys for a Private Call connection with the output params from\n      PhoneCallAccepted when is an outgoing call or PhoneCall when is an incoming call.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\ng_a_or_b = ... # Obtain the parameter for key exchange\nfingerprint = ... # Obtain the fingerprint (Optional for outgoing calls)\nparams = await app.exchange_keys(\n    -1001185324811,\n    g_a_or_b,\n    fingerprint\n)"
    },
    "details": {
      "signature": "async NTgCalls.exchange_keys() -> ntgcalls.AuthParams",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "g_a_or_b",
              "type": "bytes",
              "description": " Parameter for key exchange.",
              "source_config": null,
              "value": null
            },
            {
              "name": "fingerprint",
              "type": "int",
              "description": " Fingerprint for the connection (Optional when is an outgoing call).",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionError\nA connection with the specified ID is already established or does not exist. exception ntgcalls.CryptoError",
              "source_config": "P2P_CONN_ERROR",
              "value": null
            },
            {
              "name": "exception ntgcalls.InvalidParams",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Exchange Keys"
  },
  "/NTgCalls/Basic Methods/Init Exchange.xml": {
    "title": "Init Exchange",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows initializing a Private Call connection that can be used to exchange keys and connect with the output params from\n      GetDhConfig and PhoneCallRequested when is an incoming call\n      and then use the output params for AcceptCall (When is an incoming call) or RequestCall with Protocol.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\ndh_config = ... # Obtain the DH configuration\ng_a_hash = ... # Parameter for key exchange (Only when is incoming call)\nparams = await app.init_exchange(\n    -1001185324811,\n    config,\n    g_a_hash,\n)"
    },
    "details": {
      "signature": "async NTgCalls.init_exchange()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "config",
              "type": "ntgcalls.DhConfig",
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "g_a_hash",
              "type": "Optional[bytes]",
              "description": " Parameter for key exchange (Only when is incoming call).",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            },
            {
              "name": "exception ntgcalls.ConnectionError",
              "type": null,
              "description": " When the exchange was already initialized.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Init Exchange"
  },
  "/NTgCalls/Basic Methods/Init Presentation.xml": {
    "title": "Init Presentation",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows initializing a presentation connection, which is a connection for sharing the screen.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.init_presentation(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.init_presentation()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Init Presentation"
  },
  "/NTgCalls/Basic Methods/Skip Exchange.xml": {
    "title": "Skip Exchange",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows skipping the exchange of keys for a Private Call connection by using the encryption key already exchanged.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\nencryption_key = ... # Obtain the encryption key\napp = NTgCalls()\nawait app.skip_exchange(\n    -1001185324811,\n    encryption_key,\n    True,\n)"
    },
    "details": {
      "signature": "async NTgCalls.skip_exchange()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "encryption_key",
              "type": "bytes",
              "description": " Encryption key for the connection.",
              "source_config": null,
              "value": null
            },
            {
              "name": "is_outgoing",
              "type": "bool",
              "description": " Whether the call is outgoing.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            },
            {
              "name": "exception ntgcalls.ConnectionError",
              "type": null,
              "description": " When the connection was already established or the key already exchanged.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Skip Exchange"
  },
  "/NTgCalls/Basic Methods/Stop Presentation.xml": {
    "title": "Stop Presentation",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows stopping the presentation connection.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.stop_presentation(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.stop_presentation()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "exception ntgcalls.ConnectionError",
              "type": null,
              "description": " exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Stop Presentation"
  },
  "/NTgCalls/Basic Methods/Stop.xml": {
    "title": "Stop",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allow stopping a WebRTC connection.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.stop(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.stop()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/Stop"
  },
  "/NTgCalls/Basic Methods/ntg_connect.xml": {
    "title": "ntg_connect",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows connecting to Telegram Group Calls with the output params from Telegram method\n      JoinGroupCall.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    char* params = ...;  // Obtain connection parameters\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_connect(uid, chatID, params, False, &future);\n    // Wait for the async operation to complete\n    ...\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_connect()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "char* params",
              "type": null,
              "description": " Connection params obtained from Telegram.",
              "source_config": null,
              "value": null
            },
            {
              "name": "bool is_presentation",
              "type": null,
              "description": " Whether the connection is for a presentation. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "#NTG_RTMP_NEEDED -300",
              "type": null,
              "description": " #NTG_INVALID_TRANSPORT -301\nThe specified transport is invalid.",
              "source_config": null,
              "value": null
            },
            {
              "name": "#NTG_CONNECTION_FAILED -302",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_connect"
  },
  "/NTgCalls/Basic Methods/ntg_connect_p2p.xml": {
    "title": "ntg_connect_p2p",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows connecting to a Private Call with the output params from Telegram method\n      ConfirmCall when is an outgoing call or PhoneCall when is an incoming call.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_rtc_server_struct* rtcServers = ...; // Obtain the RTC servers\n    int rtcServersCount = ...; // Obtain the count of RTC servers\n    char** libraryVersions = ...; // Obtain the library versions\n    int libraryVersionCount = ...; // Obtain the count of library versions\n    bool p2pAllowed = ...; // Obtain whether P2P is allowed\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_connect_p2p(\n        uid,\n        chatID,\n        rtcServers,\n        rtcServersCount,\n        libraryVersions,\n        libraryVersionCount,\n        p2pAllowed,\n        &future\n    );\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_connect_p2p()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_rtc_server_struct* servers",
              "type": null,
              "description": " List of endpoints the user can connect to exchange call data.",
              "source_config": null,
              "value": null
            },
            {
              "name": "int serversSize",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "char** versions",
              "type": null,
              "description": " When using RequestCall and AcceptCall,\n        specify all library versions supported by the client.\n        The server will merge and choose the best library version supported by both peers, returning only the best\n        value in the result of the call's AcceptCall and in the PhoneCallAccepted update received by the caller.",
              "source_config": null,
              "value": null
            },
            {
              "name": "int versionsSize",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "bool p2pAllowed",
              "type": null,
              "description": " Whether to allow P2P connection to the other participant. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_CONNECTION_ALREADY_EXISTS -100\nA connection with the specified ID already exists. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found. #NTG_CRYPTO_ERROR -102",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "#NTG_SIGNALING_ERROR -104",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "#NTG_SIGNALING_UNSUPPORTED -105",
              "type": null,
              "description": " #NTG_INVALID_TRANSPORT -301\nThe specified transport is invalid.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_connect_p2p"
  },
  "/NTgCalls/Basic Methods/ntg_create.xml": {
    "title": "ntg_get_params",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting connection params for Telegram WebRTC connection.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_media_description_struct desc = {\n        // Fill in media description fields\n    };\n    char buffer[512];\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_create(uid, chatID, desc, buffer, sizeof(buffer));\n    // Wait for the async operation to complete and\n    // use 'buffer' for JoinGroupCall\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_get_params()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "ARG_MEDIA_C]",
              "description": "",
              "source_config": "ARG_MEDIA_C",
              "value": null
            },
            {
              "name": "char* buffer",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "ARG_BUF_SIZE]",
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_BUF_SIZE",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "SMALL_BUFF_EXCEPTION]",
              "description": " #NTG_CONNECTION_ALREADY_EXISTS -100\nA connection with the specified ID already exists. #NTG_FILE_NOT_FOUND -200\nThe specified file was not found.\n#NTG_ENCODER_NOT_FOUND -201\nThe required encoder was not found.\n#NTG_FFMPEG_NOT_FOUND -202\nFFmpeg is not found in the system.\n#NTG_SHELL_ERROR -203\nAn error occurred while executing a shell command.",
              "source_config": "SMALL_BUFF_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_create"
  },
  "/NTgCalls/Basic Methods/ntg_create_p2p.xml": {
    "title": "ntg_create_p2p",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows creating a Private Call connection that can be used to exchange keys and connect",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_media_description_struct desc = {\n        // Fill in media description fields\n    };\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_create_p2p(\n        uid,\n        chatID,\n        desc,\n        &future\n    );\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_create_p2p()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "ARG_MEDIA_C]",
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_MEDIA_C",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found. #NTG_CONNECTION_ALREADY_EXISTS -100\nA connection with the specified ID already exists. #NTG_FILE_NOT_FOUND -200\nThe specified file was not found.\n#NTG_ENCODER_NOT_FOUND -201\nThe required encoder was not found.\n#NTG_FFMPEG_NOT_FOUND -202\nFFmpeg is not found in the system.\n#NTG_SHELL_ERROR -203\nAn error occurred while executing a shell command.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_create_p2p"
  },
  "/NTgCalls/Basic Methods/ntg_exchange_keys.xml": {
    "title": "ntg_exchange_keys",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows exchanging keys for a Private Call connection with the output params from\n      PhoneCallAccepted when is an outgoing call or PhoneCall when is an incoming call.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    uint8_t* g_a_or_b = ...; // Obtain the parameter for key exchange\n    int sizeGAOrB = ...; // Obtain the size of the parameter for key exchange\n    int64_t fingerprint = ...; // Obtain the fingerprint\n    ntg_auth_params_struct buffer;\n    // Initialize the async struct\n    ntg_async_struct future;\n    int result = ntg_exchange_keys(uid, chatID, g_a_or_b, sizeGAOrB, fingerprint, &buffer, &future);\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_exchange_keys()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "uint8_t* g_a_or_b",
              "type": null,
              "description": " Parameter for key exchange.",
              "source_config": null,
              "value": null
            },
            {
              "name": "int sizeGAOrB",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "int64_t fingerprint",
              "type": null,
              "description": " Fingerprint for the connection (Optional when is an outgoing call).",
              "source_config": null,
              "value": null
            },
            {
              "name": "ntg_auth_params_struct* authParams",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_CONNECTION_ALREADY_EXISTS -100\nA connection with the specified ID already exists. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found. #NTG_CRYPTO_ERROR -102",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "#NTG_MISSING_FINGERPRINT -103",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_exchange_keys"
  },
  "/NTgCalls/Basic Methods/ntg_init_exchange.xml": {
    "title": "ntg_init_exchange",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows initializing a Private Call connection that can be used to exchange keys and connect with the output params from\n      GetDhConfig and PhoneCallRequested when is an incoming call\n      and then use the output params for AcceptCall (When is an incoming call) or RequestCall with Protocol.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_dh_config_struct dhConfig = ...; // Obtain the DH configuration\n    uint8_t* g_a_hash = ...; // Parameter for key exchange (Only when is incoming call)\n    int sizeG_A_Hash = ...; // Size of the parameter for key exchange (Only when is incoming call)\n    uint8_t* buffer[32];\n    // Initialize the async struct\n    ntg_async_struct future;\n    int result = ntg_init_exchange(\n        uid,\n        chatID,\n        &dhConfig,\n        g_a_hash,\n        sizeG_A_Hash,\n        buffer,\n        sizeof(buffer),\n        &future\n    );\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_init_exchange()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_dh_config_struct* dhConfig",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "uint8_t* g_a_hash",
              "type": null,
              "description": " Parameter for key exchange (Only when is incoming call).",
              "source_config": null,
              "value": null
            },
            {
              "name": "int sizeGAHash",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "uint8_t* buffer",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "int sizeBuffer",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "#NTG_ERROR_CONNECTION -302",
              "type": null,
              "description": " When the exchange was already initialized.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_init_exchange"
  },
  "/NTgCalls/Basic Methods/ntg_init_presentation.xml": {
    "title": "ntg_init_presentation",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows initializing a presentation connection, which is a connection for sharing the screen.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_init_presentation(uid, chatID, &future);\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_init_presentation()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_init_presentation"
  },
  "/NTgCalls/Basic Methods/ntg_skip_exchange.xml": {
    "title": "ntg_skip_exchange",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows skipping the exchange of keys for a Private Call connection by using the encryption key already exchanged.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    uint8_t* encryption_key = ... # Obtain the encryption key\n    int size = ...; // Obtain the size of the encryption key\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_skip_exchange(uid, chatID, encryption_key, size, False, &future);\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_skip_exchange()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "uint8_t* encryption_key",
              "type": null,
              "description": " Encryption key for the connection.",
              "source_config": null,
              "value": null
            },
            {
              "name": "int size",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "bool is_outgoing",
              "type": null,
              "description": " Whether the call is outgoing. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            },
            {
              "name": "#NTG_ERROR_CONNECTION -302",
              "type": null,
              "description": " When the connection was already established or the key already exchanged.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_skip_exchange"
  },
  "/NTgCalls/Basic Methods/ntg_stop.xml": {
    "title": "ntg_stop",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allow stopping a WebRTC connection.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    char* params = ...;  // Obtain connection parameters\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_stop(uid, chatID);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_stop()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_stop"
  },
  "/NTgCalls/Basic Methods/ntg_stop_presentation.xml": {
    "title": "ntg_stop_presentation",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows stopping the presentation connection.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    // Initialize the async struct\n    ntg_async_struct future;\n    ntg_stop_presentation(uid, chatID, &future);\n    // Wait for the async operation to complete\n}"
    },
    "details": {
      "signature": "int ntg_stop_presentation()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Basic Methods/ntg_stop_presentation"
  },
  "/NTgCalls/Build Guide.xml": {
    "title": "Introduction",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        Being a modern library, ",
    "example": {},
    "details": {},
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Build Guide"
  },
  "/NTgCalls/Callback Registration.xml": {
    "title": "Callback Registration",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "When registering callbacks, keep in mind that each registration replaces the previously set callback.",
    "example": {},
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a stream playback ends. When a stream ends, this callback will be triggered.",
              "source_config": "CALLBACK_END_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_stream_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when is needed to update GroupCall MTProto Configurations.",
              "source_config": "CALLBACK_UPGRADE_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_upgrade_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback to listen for when the WebRTC connection has changed his state.",
              "source_config": "CALLBACK_CONN_CHANGE_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_connection_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a signaling message is received.",
              "source_config": "CALLBACK_SIGNALING_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_signaling_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a group of frames is received.",
              "source_config": "CALLBACK_FRAMES_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_frames_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when the remote source changes.",
              "source_config": "CALLBACK_REMOTE_SOURCE_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": "",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "ntg_remote_source_callback callback",
              "type": null,
              "description": " void* userData\nCustom data that can be passed to the callback function.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Register a logger for the library, this logger will be used for all instances.",
              "source_config": "REGISTER_LOGGER_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "ntg_log_message_callback callback",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Callback Registration"
  },
  "/NTgCalls/Callbacks.xml": {
    "title": "Callbacks",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "When registering callbacks, keep in mind that each registration replaces the previously set callback.",
    "example": {},
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a stream playback ends. When a stream ends, this callback will be triggered.",
              "source_config": "CALLBACK_END_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when is needed to update GroupCall MTProto Configurations.",
              "source_config": "CALLBACK_UPGRADE_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback to listen for when the WebRTC connection has changed his state.",
              "source_config": "CALLBACK_CONN_CHANGE_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a signaling message is received.",
              "source_config": "CALLBACK_SIGNALING_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when a group of frames is received.",
              "source_config": "CALLBACK_FRAMES_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Callback for handling when the remote source changes.",
              "source_config": "CALLBACK_REMOTE_SOURCE_DESC",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Callbacks"
  },
  "/NTgCalls/Client.xml": {
    "title": "NTgCalls Client",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        Welcome to the API Reference section, where you'll find comprehensive information about the NTgCalls API.\n        This is your gateway to in-depth details about the main Client class, its methods, types,\n        all of which play a crucial role in utilizing NTgCalls effectively.\n    ",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n\napp = NTgCalls()\nprint(app.ping())"
    },
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "The NTgCalls Client is your primary interface for seamless interaction with Group Calls.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "STATIC METHODS",
          "items": [
            {
              "name": "async calls() -> dict[int, ntgcalls.StreamStatus]",
              "type": null,
              "description": " Get a list of all calls.",
              "source_config": null,
              "value": null
            },
            {
              "name": "async cpu_usage() -> float",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "ping() -> str",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "get_protocol() -> ntgcalls.Protocol",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "get_media_devices() -> ntgcalls.MediaDevices",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "enable_glib_loop()",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "enable_h264_encoder()",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "enable",
              "type": "bool",
              "description": " Enable or disable the GLib main loop.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "enable",
              "type": "bool",
              "description": " Enable or disable the H264 encoder.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Client"
  },
  "/NTgCalls/Getting Started.xml": {
    "title": "Getting Started",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        This section provides documentation for the NTgCalls C API, which allows you to use NTgCalls in various programming languages,\n        including C, C++, Go, Rust, Deno, and more.\n        Below, you will find detailed information about the initialization and cleanup functions.\n    ",
    "example": {},
    "details": {
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "char* buffer",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "[UNRESOLVED",
              "type": "ARG_BUF_SIZE]",
              "description": "",
              "source_config": "ARG_BUF_SIZE",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "SMALL_BUFF_EXCEPTION]",
              "description": "",
              "source_config": "SMALL_BUFF_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Getting Started"
  },
  "/NTgCalls/Quick Start.xml": {
    "title": "Quick Start",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        Welcome to this section, which is primarily intended for developers who are moderately experienced or\n        seeking to perform a porting in their language using C bindings. If you are new to Python development,\n        we strongly recommend using ",
    "example": {},
    "details": {},
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Quick Start"
  },
  "/NTgCalls/Stream Methods/Mute.xml": {
    "title": "Mute",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to mute the WebRTC stream.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.mute(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.mute() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/Mute"
  },
  "/NTgCalls/Stream Methods/Pause.xml": {
    "title": "Pause",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to pause the WebRTC stream.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.pause(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.pause() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/Pause"
  },
  "/NTgCalls/Stream Methods/Resume.xml": {
    "title": "Resume",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to resume the WebRTC stream.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.resume(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.resume() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/Resume"
  },
  "/NTgCalls/Stream Methods/Set Stream Sources.xml": {
    "title": "Set Stream Sources",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows changing the streaming file in a Group Call.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\nfrom ntgcalls import StreamMode\nfrom ntgcalls import MediaDescription\nfrom ntgcalls import AudioDescription\n...\n\napp = NTgCalls()\n\nawait app.set_stream_sources(\n    -1001185324811,\n    StreamMode.CAPTURE,\n    MediaDescription(\n        AudioDescription(\n            input_mode=InputMode.File,\n            input=\"foxes.pcm\",\n            sample_rate=96000,\n            bits_per_sample=16,\n            channel_count=2,\n        ),\n    )\n)"
    },
    "details": {
      "signature": "async NTgCalls.set_stream_sources()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            },
            {
              "name": "direction",
              "type": "ntgcalls.StreamMode",
              "description": "Stream direction for the stream.",
              "source_config": "STREAM_MODE",
              "value": null
            },
            {
              "name": "media",
              "type": "ntgcalls.MediaDescription",
              "description": "Media parameters of the stream.",
              "source_config": "ARG_STREAM_PARAMS",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found. exception ntgcalls.InvalidParams\nThis error occurs when attempting to send an invalid MediaSource.\nexception ntgcalls.FileError\nThe specified file does not exist.\nexception ntgcalls.ShellError\nError while executing the shell script.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/Set Stream Sources"
  },
  "/NTgCalls/Stream Methods/Time.xml": {
    "title": "Time",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting the played time of the stream.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls(client)\n\nprint(\n    await app.time(\n        -1001185324811,\n    )\n)"
    },
    "details": {
      "signature": "async NTgCalls.time() -> int",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "direction",
              "type": "ntgcalls.StreamMode",
              "description": "Stream direction for the stream.",
              "source_config": "STREAM_MODE",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/Time"
  },
  "/NTgCalls/Stream Methods/UnMute.xml": {
    "title": "UnMute",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to unmute the WebRTC stream.",
    "example": {
      "language": "python",
      "code": "from ntgcalls import NTgCalls\n...\n\napp = NTgCalls()\n...\n\nawait app.unmute(\n    -1001185324811,\n)"
    },
    "details": {
      "signature": "async NTgCalls.unmute() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "int",
              "description": "Unique identifier of a chat.",
              "source_config": "ARG_INT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception ntgcalls.ConnectionNotFound\nThe specified connection was not found.",
              "source_config": "CONNECTION_NOT_FOUND_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/UnMute"
  },
  "/NTgCalls/Stream Methods/ntg_mute.xml": {
    "title": "ntg_mute",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to mute the WebRTC stream.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_async_struct future;\n    // Initialize the async struct\n    int errCode = ntg_mute(uid, chatID, &future);\n    // Wait for the async operation to complete\n    if (future.errorCode == 0) {\n        printf(\"Audio muted.\\n\");\n    } else if (future.errorCode == 1) {\n        printf(\"Audio was already muted.\\n\");\n    } else {\n        printf(\"Failed to mute audio (Error code: %d).\\n\", future.errorCode);\n        return 1;\n    }\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_mute()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_mute"
  },
  "/NTgCalls/Stream Methods/ntg_pause.xml": {
    "title": "ntg_pause",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to pause the WebRTC stream.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_async_struct future;\n    // Initialize the async struct\n    int errCode = ntg_pause(uid, chatID);\n    // Wait for the async operation to complete\n    if (future.errorCode == 0) {\n        printf(\"Audio paused.\\n\");\n    } else if (future.errorCode == 1) {\n        printf(\"Audio was already paused.\\n\");\n    } else {\n        printf(\"Failed to pause audio (Error code: %d).\\n\", result);\n        return 1;\n    }\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_pause()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_pause"
  },
  "/NTgCalls/Stream Methods/ntg_resume.xml": {
    "title": "ntg_resume",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to resume the WebRTC stream.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_async_struct future;\n    // Initialize the async struct\n    int errCode = ntg_resume(uid, chatID, &future);\n    // Wait for the async operation to complete\n    if (future.errorCode == 0) {\n        printf(\"Audio resumed.\\n\");\n    } else if (future.errorCode == 1) {\n        printf(\"Audio was already resumed.\\n\");\n    } else {\n        printf(\"Failed to resume audio (Error code: %d).\\n\", result);\n        return 1;\n    }\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_resume()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_resume"
  },
  "/NTgCalls/Stream Methods/ntg_set_stream_sources.xml": {
    "title": "ntg_set_stream_sources",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows changing the streaming file in a Group Call.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_media_description_struct desc = {\n        // Fill in updated media description fields\n    };\n    ntg_async_struct future;\n    // Initialize the async struct\n    int result = ntg_set_stream_sources(uid, chatID, NTG_STREAM_CAPTURE, desc, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_set_stream_sources()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_stream_mode_enum streamMode\nStream direction for the stream. ntg_media_description_struct desc\nMedia parameters of the stream. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found. #NTG_FILE_NOT_FOUND -200\nThe specified file was not found.\n#NTG_ENCODER_NOT_FOUND -201\nThe required encoder was not found.\n#NTG_FFMPEG_NOT_FOUND -202\nFFmpeg is not found in the system.\n#NTG_SHELL_ERROR -203\nAn error occurred while executing a shell command.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_set_stream_sources"
  },
  "/NTgCalls/Stream Methods/ntg_time.xml": {
    "title": "ntg_time",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows getting the played time of the stream.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    int64_t time = 0;\n    ntg_async_struct future;\n    // Initialize the async struct\n    int64_t result = ntg_time(uid, chatID, NTG_STREAM_CAPTURE, &time, &future);\n    // Wait for the async operation to complete\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_time()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_stream_mode_enum streamMode\nStream direction for the stream.",
              "source_config": "ARG_C_UID",
              "value": null
            },
            {
              "name": "int64_t* time",
              "type": null,
              "description": " ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_time"
  },
  "/NTgCalls/Stream Methods/ntg_unmute.xml": {
    "title": "ntg_unmute",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "This method allows you to unmute the WebRTC stream.",
    "example": {
      "language": "c",
      "code": "#include <stdint.h>\n#include \"ntgcalls.h\"\n\nint main() {\n    uint32_t uid = ntg_init();\n    ...\n    int64_t chatID = ...; // Obtain the chat ID\n    ntg_async_struct future;\n    // Initialize the async struct\n    int errCode = ntg_unmute(uid, chatID, &future);\n    // Wait for the async operation to complete\n    if (future.errorCode == 0) {\n        printf(\"Audio unmuted.\\n\");\n    } else if (future.errorCode == 1) {\n        printf(\"Audio was already unmuted.\\n\");\n    } else {\n        printf(\"Failed to unmute audio (Error code: %d).\\n\", future.errorCode);\n        return 1;\n    }\n    ... // Your Code Here\n    return 0;\n}"
    },
    "details": {
      "signature": "int ntg_unmute()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "[UNRESOLVED",
              "type": "ARG_C_UID]",
              "description": " int64_t chatID\nUnique identifier of a chat. ntg_async_struct* future\nThe ntg_async_struct instance that will be used to track the async operation.",
              "source_config": "ARG_C_UID",
              "value": null
            }
          ]
        },
        {
          "title": "ERROR CODES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "#NTG_INVALID_UID -2\nThe provided UID is invalid. #NTG_UNKNOWN_EXCEPTION -1\nAn unknown exception occurred.\n#NTG_CONNECTION_NOT_FOUND -101\nThe specified connection was not found.",
              "source_config": "BASE_SYNC_C_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Stream Methods/ntg_unmute"
  },
  "/NTgCalls/Using Async.xml": {
    "title": "Using Async",
    "lib": "NTgCalls",
    "kind": "method",
    "description": "\n        NTgCalls starting from version 1.2.0 supports asynchronous calls to function using ",
    "example": {
      "language": "cpp",
      "code": "#include <ntgcalls.h>\n#include <mutex>\n\nvoid onCallReady(void* data) {\n    ((std::mutex*)data)->unlock();\n}\n\nvoid makeAsyncCall() {\n    ntg_async_struct asyncData;\n    std::mutex mtx;\n    asyncData.userData = &mtx;\n    asyncData.promise = onCallReady;\n    mtx.lock();\n    int error = ntg_pause(asyncData);\n    if (error != 0) {\n        // Handle error\n    }\n    mtx.lock();\n    // Async operation completed\n    if (asyncData.errorCode != 0) {\n        // Handle Async error\n    }\n}"
    },
    "details": {},
    "doc_url": "https://pytgcalls.github.io/NTgCalls/Using Async"
  },
  "/PyTgCalls/Advanced Methods/Change Volume Call.xml": {
    "title": "Change Volume Call",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method changes the userbots output volume using MTProto APIs.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.change_volume_call(\n    -1001185324811,\n    175,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.change_volume_call()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "volume",
              "type": "int",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.\nexception pytgcalls.exceptions.NoActiveGroupCall\nYou cannot edit a group call that hasn't been initiated. exception pytgcalls.exceptions.UnsupportedMethod\nThis error occurs when attempting to execute an action on a call kind that doesn't support it.",
              "source_config": "CONNECTION_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Methods/Change Volume Call"
  },
  "/PyTgCalls/Advanced Methods/Get Participants.xml": {
    "title": "Get Participants",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method returns the list of a group calls participants using MTProto APIs.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.get_participants(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.get_participants() -> list[GroupCall]",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.UnsupportedMethod\nThis error occurs when attempting to execute an action on a call kind that doesn't support it.",
              "source_config": "UNSUPPORTED_METHOD_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Methods/Get Participants"
  },
  "/PyTgCalls/Advanced Methods/Send Frame.xml": {
    "title": "Send Frame",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows sending an external frame to the group call or private call.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls\nfrom pytgcalls import Device\nfrom pytgcalls.types import Frame\nfrom datetime import datetime\n...\n\napp = PyTgCalls()\n...\npcm16_le_data = ...\n\napp.send_frame(\n    -1001185324811,\n    Device.MICROPHONE,\n    pcm16_le_data,\n    Frame.Info(\n        int(datetime.now().timestamp()),\n    )\n)"
    },
    "details": {
      "signature": "PyTgCalls.send_frame()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "device",
              "type": "pytgcalls.Device",
              "description": " Device Kind",
              "source_config": null,
              "value": null
            },
            {
              "name": "frame",
              "type": "bytes",
              "description": " Frame buffer",
              "source_config": null,
              "value": null
            },
            {
              "name": "frame_data",
              "type": "pytgcalls.Frame.Info",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Methods/Send Frame"
  },
  "/PyTgCalls/Advanced Types/Call.xml": {
    "title": "Call",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Call"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/Call"
  },
  "/PyTgCalls/Advanced Types/CallConfig.xml": {
    "title": "CallConfig",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.CallConfig"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/CallConfig"
  },
  "/PyTgCalls/Advanced Types/ChatUpdate.xml": {
    "title": "ChatUpdate",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.ChatUpdate"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/ChatUpdate"
  },
  "/PyTgCalls/Advanced Types/Frame Info.xml": {
    "title": "Frame Info",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Frame.Info"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/Frame Info"
  },
  "/PyTgCalls/Advanced Types/Frame.xml": {
    "title": "Frame",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Frame"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/Frame"
  },
  "/PyTgCalls/Advanced Types/GroupCallConfig.xml": {
    "title": "GroupCallConfig",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.GroupCallConfig"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/GroupCallConfig"
  },
  "/PyTgCalls/Advanced Types/GroupCallParticipant.xml": {
    "title": "GroupCallParticipant",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.GroupCallParticipant"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/GroupCallParticipant"
  },
  "/PyTgCalls/Advanced Types/StreamEnded.xml": {
    "title": "StreamEnded",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.StreamEnded"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/StreamEnded"
  },
  "/PyTgCalls/Advanced Types/StreamFrames.xml": {
    "title": "StreamFrames",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.StreamFrames"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/StreamFrames"
  },
  "/PyTgCalls/Advanced Types/UpdatedGroupCallParticipant.xml": {
    "title": "UpdatedGroupCallParticipant",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.UpdatedGroupCallParticipant"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Advanced Types/UpdatedGroupCallParticipant"
  },
  "/PyTgCalls/Available Enums/AudioQuality.xml": {
    "title": "AudioQuality",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration of audio quality settings for audio streams in telegram calls.",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.AudioQuality",
      "members": [
        {
          "name": "STUDIO",
          "type": null,
          "description": " Represents studio-quality audio with a bitrate of 96000 and 2 channels.",
          "source_config": null,
          "value": "(96000, 2)"
        },
        {
          "name": "HIGH",
          "type": null,
          "description": " Represents high-quality audio with a bitrate of 48000 and 2 channels.",
          "source_config": null,
          "value": "(48000, 2)"
        },
        {
          "name": "MEDIUM",
          "type": null,
          "description": " Represents medium-quality audio with a bitrate of 36000 and 1 channel.",
          "source_config": null,
          "value": "(36000, 1)"
        },
        {
          "name": "LOW",
          "type": null,
          "description": " Represents low-quality audio with a bitrate of 24000 and 1 channel. Represents studio-quality audio with a bitrate of 96000 and 2 channels. Represents high-quality audio with a bitrate of 48000 and 2 channels. Represents medium-quality audio with a bitrate of 36000 and 1 channel. Represents low-quality audio with a bitrate of 24000 and 1 channel.",
          "source_config": null,
          "value": "(24000, 1)"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/AudioQuality"
  },
  "/PyTgCalls/Available Enums/Call Status.xml": {
    "title": "Call Status",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for managing call statuses.",
    "example": {},
    "details": {
      "signature": "class Call.Status",
      "members": [
        {
          "name": "PLAYING",
          "type": null,
          "description": " Indicates that the call is playing.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "PAUSED",
          "type": null,
          "description": " Indicates that the call is paused.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "IDLE",
          "type": null,
          "description": " Indicates that the call is idle. Indicates that the call is playing. Indicates that the call is paused. Indicates that the call is idle.",
          "source_config": null,
          "value": "4"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/Call Status"
  },
  "/PyTgCalls/Available Enums/Call Type.xml": {
    "title": "Call Type",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for managing call types.",
    "example": {},
    "details": {
      "signature": "class Call.Type",
      "members": [
        {
          "name": "GROUP",
          "type": null,
          "description": " Group call type.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "PRIVATE",
          "type": null,
          "description": " Private call type. Group call type. Private call type.",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/Call Type"
  },
  "/PyTgCalls/Available Enums/ChatUpdate Status.xml": {
    "title": "ChatUpdate Status",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for managing chat update status in telegram calls.",
    "example": {},
    "details": {
      "signature": "class ChatUpdate.Status",
      "members": [
        {
          "name": "KICKED",
          "type": null,
          "description": " Indicates that you was kicked.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "LEFT_GROUP",
          "type": null,
          "description": " Indicates that you left the chat.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "CLOSED_VOICE_CHAT",
          "type": null,
          "description": " Indicates that the voice chat was closed.",
          "source_config": null,
          "value": "4"
        },
        {
          "name": "INVITED_VOICE_CHAT",
          "type": null,
          "description": " Indicates that you was invited to the voice chat.",
          "source_config": null,
          "value": "8"
        },
        {
          "name": "DISCARDED_CALL",
          "type": null,
          "description": " Indicates that the call was discarded.",
          "source_config": null,
          "value": "16"
        },
        {
          "name": "INCOMING_CALL",
          "type": null,
          "description": " Indicates that an incoming call is available.",
          "source_config": null,
          "value": "32"
        },
        {
          "name": "LEFT_CALL",
          "type": null,
          "description": " Indicates that you left the call. Indicates that you was kicked. Indicates that you left the chat. Indicates that the voice chat was closed. Indicates that you was invited to the voice chat. Indicates that the call was discarded. Indicates that an incoming call is available. Indicates that you left the call.",
          "source_config": null,
          "value": "KICKED | LEFT_GROUP | CLOSED_VOICE_CHAT | DISCARDED_CALL"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/ChatUpdate Status"
  },
  "/PyTgCalls/Available Enums/Device.xml": {
    "title": "Device",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration of stream device values.",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Device",
      "members": [
        {
          "name": "MICROPHONE",
          "type": null,
          "description": " Input mode using a microphone source.",
          "source_config": null,
          "value": "0"
        },
        {
          "name": "SPEAKER",
          "type": null,
          "description": " Input mode using a speaker source.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "CAMERA",
          "type": null,
          "description": " Input mode using a camera source.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "SCREEN",
          "type": null,
          "description": " Input mode using a screen source.",
          "source_config": null,
          "value": "3"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/Device"
  },
  "/PyTgCalls/Available Enums/Direction.xml": {
    "title": "Direction",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Stream direction for the stream.",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Direction",
      "members": [
        {
          "name": "OUTGOING",
          "type": null,
          "description": " Direction for sending the stream.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "INCOMING",
          "type": null,
          "description": " Direction for receiving the stream.",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/Direction"
  },
  "/PyTgCalls/Available Enums/ExternalMedia.xml": {
    "title": "ExternalMedia",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for the kind of media that is being played externally.",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.ExternalMedia",
      "members": [
        {
          "name": "AUDIO",
          "type": null,
          "description": " Indicates that the stream type is audio.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "VIDEO",
          "type": null,
          "description": " Indicates that the stream type is video.",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/ExternalMedia"
  },
  "/PyTgCalls/Available Enums/GroupCallParticipant Action.xml": {
    "title": "GroupCallParticipant Action",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration of actions for group call participants.",
    "example": {},
    "details": {
      "signature": "class GroupCallParticipant.Action",
      "members": [
        {
          "name": "JOINED",
          "type": null,
          "description": " Represents a participant joined in a group call.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "LEFT",
          "type": null,
          "description": " Represents a participant left a group call.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "UPDATED",
          "type": null,
          "description": " Represents a participant updated in a group call. Represents a participant joined in a group call. Represents a participant left a group call. Represents a participant updated in a group call.",
          "source_config": null,
          "value": "4"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/GroupCallParticipant Action"
  },
  "/PyTgCalls/Available Enums/MediaStream Flags.xml": {
    "title": "MediaStream Flags",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for managing media stream requirements in telegram calls.",
    "example": {},
    "details": {
      "signature": "class MediaStream.Flags",
      "members": [
        {
          "name": "AUTO_DETECT",
          "type": null,
          "description": " Automatically detects the presence of the stream.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "IGNORE",
          "type": null,
          "description": " Ignores the stream.",
          "source_config": null,
          "value": "2"
        },
        {
          "name": "REQUIRED",
          "type": null,
          "description": " Indicates that the stream is mandatory.",
          "source_config": null,
          "value": "4"
        },
        {
          "name": "NO_LATENCY",
          "type": null,
          "description": " Used to indicate that the stream should be sent with no latency. Automatically detects the presence of the stream. Ignores the stream. Indicates that the stream is mandatory. Used to indicate that the stream should be sent with no latency.",
          "source_config": null,
          "value": "8"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/MediaStream Flags"
  },
  "/PyTgCalls/Available Enums/StreamEnded Type.xml": {
    "title": "StreamEnded Type",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration for managing the type of stream that has ended.",
    "example": {},
    "details": {
      "signature": "class StreamEnded.Type",
      "members": [
        {
          "name": "AUDIO",
          "type": null,
          "description": " Indicates that the stream type is audio.",
          "source_config": null,
          "value": "1"
        },
        {
          "name": "VIDEO",
          "type": null,
          "description": " Indicates that the stream type is video.",
          "source_config": null,
          "value": "2"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/StreamEnded Type"
  },
  "/PyTgCalls/Available Enums/VideoQuality.xml": {
    "title": "VideoQuality",
    "lib": "PyTgCalls",
    "kind": "enum",
    "description": "Enumeration of video quality settings for video streams in telegram calls.",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.VideoQuality",
      "members": [
        {
          "name": "UHD_4K",
          "type": null,
          "description": " Represents ultra-high-definition 4K video with a resolution of 3840x2160 and 60 FPS.",
          "source_config": null,
          "value": "(3840, 2160, 60)"
        },
        {
          "name": "QHD_2K",
          "type": null,
          "description": " Represents quad high-definition 2K video with a resolution of 2560x1440 and 60 FPS.",
          "source_config": null,
          "value": "(2560, 1440, 60)"
        },
        {
          "name": "FHD_1080p",
          "type": null,
          "description": " Represents full high-definition 1080p video with a resolution of 1920x1080 and 60 FPS.",
          "source_config": null,
          "value": "(1920, 1080, 60)"
        },
        {
          "name": "HD_720p",
          "type": null,
          "description": " Represents high-definition 720p video with a resolution of 1280x720 and 30 FPS.",
          "source_config": null,
          "value": "(1280, 720, 30)"
        },
        {
          "name": "SD_480p",
          "type": null,
          "description": " Represents standard-definition 480p video with a resolution of 854x480 and 30 FPS.",
          "source_config": null,
          "value": "(854, 480, 30)"
        },
        {
          "name": "SD_360p",
          "type": null,
          "description": " Represents standard-definition 360p video with a resolution of 640x360 and 30 FPS. Represents ultra-high-definition 4K video with a resolution of 3840x2160 and 60 FPS. Represents quad high-definition 2K video with a resolution of 2560x1440 and 60 FPS. Represents full high-definition 1080p video with a resolution of 1920x1080 and 60 FPS. Represents high-definition 720p video with a resolution of 1280x720 and 30 FPS. Represents standard-definition 480p video with a resolution of 854x480 and 30 FPS. Represents standard-definition 360p video with a resolution of 640x360 and 30 FPS.",
          "source_config": null,
          "value": "(640, 360, 30)"
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Available Enums/VideoQuality"
  },
  "/PyTgCalls/Basic Methods/Idle.xml": {
    "title": "Idle",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        This function will run indefinitely in order to block the main script\n        execution and prevent it from exiting while having client(s) that are still running in the background.\n\n        PyTgCalls works by keeping your handlers in a pool of worker threads, which run\n        concurrently outside the main thread. Calling idle() will ensure that the client(s) remain active, by\n        preventing the main script from ending until you decide to quit.\n\n        Once a signal is received (e.g.: from CTRL+C) the function will terminate and your main script will continue.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp1 = PyTgCalls(client1)\napp2 = PyTgCalls(client2)\napp3 = PyTgCalls(client3)\n\n...  # Set handlers up\n\napp1.start()\napp2.start()\napp3.start()\n\nidle()"
    },
    "details": {
      "signature": "pytgcalls.idle()"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Basic Methods/Idle"
  },
  "/PyTgCalls/Basic Methods/Leave Call.xml": {
    "title": "Leave Call",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows leaving and stopping a group call or a private call, or declining a private call.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.leave_call(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.leave_call()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.\nexception pytgcalls.exceptions.NoActiveGroupCall\nYou cannot edit a group call that hasn't been initiated.",
              "source_config": "CONNECTION_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Basic Methods/Leave Call"
  },
  "/PyTgCalls/Basic Methods/Run.xml": {
    "title": "Run",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        This is a convenience method that calls ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\napp = Client(client)\n\n...  # Call API decorators / MtProto decorators\n\napp.run()"
    },
    "details": {
      "signature": "PyTgCalls.run()",
      "sections": [
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.PyTgCallsAlreadyRunning\nThis error occurs when attempting to start a client that is already running.",
              "source_config": "RUNNING_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Basic Methods/Run"
  },
  "/PyTgCalls/Basic Methods/Start.xml": {
    "title": "Start",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        This method start and then initialize NTgCalls core.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\napp = Client(client)\n\n...  # Call API decorators / MTProto decorators\n\napp.start()"
    },
    "details": {
      "signature": "PyTgCalls.start()",
      "sections": [
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.PyTgCallsAlreadyRunning\nThis error occurs when attempting to start a client that is already running.",
              "source_config": "RUNNING_EXCEPTION",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Basic Methods/Start"
  },
  "/PyTgCalls/Calling Methods.xml": {
    "title": "Calling Methods",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        At this point, we have successfully ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls\nfrom pytgcalls import idle\n...\napi_id = 12345\napi_hash = '0123456789abcdef0123456789abcdef'\n...\napp = PyTgCalls(client)\napp.start()\napp.play(\n    -1001185324811,\n    'http://docs.evostream.com/sample_content/assets/sintel1m720p.mp4',\n)\nidle()"
    },
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Calling Methods"
  },
  "/PyTgCalls/Changelogs.xml": {
    "title": "Changelogs",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "We're pleased to announce that now is available an unofficial porting of NTgCalls for Rust, for more info, check the",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "We're pleased to announce that pre-compiled wheels optimized for ARM64 devices are now available.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Join the contest now and showcase your PyTgCalls-powered bot for a chance to be featured prominently on the PyTgCalls documentation! Good luck!",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "As we said in the last post,\n                now PyTgCalls",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": " ",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "As we know, Google is in charge of financing Python.\n                Due to the recent events with the",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Changelogs"
  },
  "/PyTgCalls/Client.xml": {
    "title": "PyTgCalls Client",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        You now are in the API Reference section. Here you can find detailed information about PyTgCalls API:\n        the main Client class, all available methods, types, attributes and decorators detailed descriptions can be found starting from this page.\n\n        This page is about the Client class, which exposes high-level methods for easy access to the API.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls\n\napp = PyTgCalls(client)\napp.start()"
    },
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "PyTgCalls Client, the main tool for interacting with Telegram Calls.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "app",
              "type": "Union[pyrogram.Client, telethon.TelegramClient, hydrogram.Client]",
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "cache_duration",
              "type": "int",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "STATIC METHODS",
          "items": [
            {
              "name": "async calls -> dict[str, Call]",
              "type": null,
              "description": " Get a list of all calls.",
              "source_config": null,
              "value": null
            },
            {
              "name": "async group_calls -> dict[str, Call]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "async private_calls -> dict[str, Call]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "cache_peer ->",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "ping -> int",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "mtproto_client -> Any",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "async cpu_usage -> float",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "exception pytgcalls.exceptions.InvalidMTProtoClient",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Client"
  },
  "/PyTgCalls/Custom Api.xml": {
    "title": "Custom API",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        You now are in the API Reference section where you can find detailed information about the Custom API:\n        the Front-end API class, all available methods, types, attributes and decorators detailed descriptions can be found starting from this page.\n\n        This page is about the CustomAPI class, which exposes high-level methods for easy access to the API.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import CustomApi\n\napi = CustomApi()\n\n@api.on_update_custom_api()\nasync def custom_api_request(request: dict):\n    print(request)\n    return {\n        'response': 'FOXES',\n    }\napi.start()"
    },
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "CustomApi, the main means host the local http api server.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "port",
              "type": "int",
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "METHODS",
          "items": [
            {
              "name": "start()",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Custom Api"
  },
  "/PyTgCalls/Decorators.xml": {
    "title": "Decorators",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        While still being methods bound to the ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls\nfrom pytgcalls.types import Update\nfrom pytgcalls import filters as call_filters\n...\nclient = # Here Your MTProto Client\napp = PyTgCalls(client)\n\n@app.on_update(call_filters.stream_end())\nasync def handler(client: PyTgCalls, update: Update):\n    print(update)\n\napp.run()"
    },
    "details": {
      "signature": "@CustomApi.on_update_custom_api()",
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Decorator for handling all incoming updates.\n                When any update is received, this decorator will be triggered.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Decorators"
  },
  "/PyTgCalls/Examples.xml": {
    "title": "Examples",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        This page contains example scripts to demonstrate how PyTgCalls looks like.\n\n        Every script is working right away (assuming you correctly set up your credentials), meaning you can simply copy-paste them\n        and run. The only things you have to modify are session names and target chats, where applicable.\n\n        The examples listed below can be treated as building blocks for your own applications and are designed to be simple enough\n        to give you a basic idea.\n    ",
    "example": {},
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Examples"
  },
  "/PyTgCalls/Filters.xml": {
    "title": "Filters",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        Filters are objects that can be used to filter the content of incoming updates.\n        ",
    "example": {},
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "Easily create a custom filter.\n\n                Custom filters give you extra control over which updates are allowed or not to be processed by your handlers. Filter updates for yourself. Filter updates for when a stream ends. Filter updates coming from one or more chats.\n                You can use Filter specific type of chat updates. Filter updates for when a call participant joins, leaves or is updated. Filter updates for when stream frames are received.",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Filters"
  },
  "/PyTgCalls/Handling Updates.xml": {
    "title": "Handling Updates",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        Calling API methods sequentially is cool, but what if, for example, the list of participants changes?\n        This page covers updates and how to handle such events in PyTgCalls. Lets have a look at how they work.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls, filters\nfrom pytgcalls.types import Update\nfrom pytgcalls.types import MediaStream\n...\napp = PyTgCalls(client)\n\n@app.on_update(filters.stream_end())\nasync def my_handler(client: PyTgCalls, update: Update):\n    if isinstance(update, StreamVideoEnded):\n        await pytgcalls.play(\n            -1001185324811,\n            'http://docs.evostream.com/sample_content/assets/sintel1m720p.mp4',\n        )\n\napp.run()"
    },
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Handling Updates"
  },
  "/PyTgCalls/Install Guide.xml": {
    "title": "Install Guide",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        Being a modern Python library, ",
    "example": {
      "language": "bash",
      "code": "$ pip3 install -U py-tgcalls"
    },
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Install Guide"
  },
  "/PyTgCalls/Media Devices.xml": {
    "title": "Media Devices",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        This class offers methods to access information regarding media devices available on your system.\n        This functionality proves valuable when you intend to stream content from either your screen or microphone.\n    ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\nfrom pytgcalls import MediaDevices\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.play(\n    -1001185324811,\n    MediaDevices.get_audio_devices()[0],\n)\n\nidle()"
    },
    "details": {
      "sections": [
        {
          "title": "",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "MediaDevices, the main tool for retrieving media devices list.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "METHODS",
          "items": [
            {
              "name": "microphone_devices() -> list[pytgcalls.InputDevice]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "speaker_devices() -> list[pytgcalls.SpeakerDevice]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "camera_devices() -> list[pytgcalls.InputDevice]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "screen_devices() -> list[pytgcalls.ScreenDevice]",
              "type": null,
              "description": "",
              "source_config": null,
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Media Devices"
  },
  "/PyTgCalls/Quick Start.xml": {
    "title": "Quick Start",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "The next few steps serve as a quick start for all new Pythoneers that want to see PyTgCalls in action as quickly as possible. Lets go!",
    "example": {},
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Quick Start"
  },
  "/PyTgCalls/Stream Descriptors/AudioParameters.xml": {
    "title": "AudioParameters",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.raw.AudioParameters"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/AudioParameters"
  },
  "/PyTgCalls/Stream Descriptors/AudioStream.xml": {
    "title": "AudioStream",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.raw.AudioStream"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/AudioStream"
  },
  "/PyTgCalls/Stream Descriptors/MediaStream.xml": {
    "title": "MediaStream",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.MediaStream"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/MediaStream"
  },
  "/PyTgCalls/Stream Descriptors/RecordStream.xml": {
    "title": "RecordStream",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.RecordStream"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/RecordStream"
  },
  "/PyTgCalls/Stream Descriptors/Stream.xml": {
    "title": "Stream",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.Stream"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/Stream"
  },
  "/PyTgCalls/Stream Descriptors/VideoParameters.xml": {
    "title": "VideoParameters",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.raw.VideoParameters"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/VideoParameters"
  },
  "/PyTgCalls/Stream Descriptors/VideoStream.xml": {
    "title": "VideoStream",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "",
    "example": {},
    "details": {
      "signature": "class pytgcalls.types.raw.VideoStream"
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Descriptors/VideoStream"
  },
  "/PyTgCalls/Stream Methods/Mute.xml": {
    "title": "Mute",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows muting the userbot via MTProto APIs.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.mute(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.mute() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Mute"
  },
  "/PyTgCalls/Stream Methods/Pause.xml": {
    "title": "Pause",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows pausing the streaming file.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.pause(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.pause() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Pause"
  },
  "/PyTgCalls/Stream Methods/Play.xml": {
    "title": "Play",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows streaming audio or video to a group call or a private call.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.play(\n    -1001185324811,\n    'test.mp4',\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.play()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "stream",
              "type": "Optional[Union[Stream, MediaStream, InputDevice, Path, str]]",
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "config",
              "type": "Optional[Union[CallConfig, GroupCallConfig]]",
              "description": "Additional configuration for the call.",
              "source_config": "CALL_CONFIG_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method. exception pytgcalls.exceptions.NoActiveGroupCall\nYou cannot edit a group call that hasn't been initiated. exception FileNotFoundError\nThe specified file does not exist.\nexception ntgcalls.FFmpegError\nTo use Piped input stream, make sure you have FFmpeg installed.\nexception ntgcalls.ShellError\nError while executing the shell script.\nexception pytgcalls.exceptions.NoAudioSourceFound\nThe audio file you're trying to play has no audio.\nexception pytgcalls.exceptions.NoVideoSourceFound\nThe video file you're trying to play has no video.\nexception pytgcalls.exceptions.InvalidVideoProportion\nPlaying a video with incorrect proportions is not supported.\nexception pytgcalls.exceptions.YtDlpError\nThis error occurs when yt-dlp encounters an error. exception pytgcalls.exceptions.CallDeclined\nThe call was declined by the user.\nexception pytgcalls.exceptions.CallBusy\nWhen the user is already in a call.\nexception pytgcalls.exceptions.CallDiscarded\nThe call was discarded by the user while connecting.\nexception ntgcalls.TelegramServerError\nThis error occurs when the connection between Telegram and the WebRTC service fails.",
              "source_config": "BASE_MTPROTO",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Play"
  },
  "/PyTgCalls/Stream Methods/Record.xml": {
    "title": "Record",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows recording audio or video from a group call or a private call.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.record(\n    -1001185324811,\n    'record.mp3',\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.record()",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "stream",
              "type": "Union[Stream, RecordStream, SpeakerDevice, Path, str]",
              "description": "",
              "source_config": null,
              "value": null
            },
            {
              "name": "config",
              "type": "Optional[Union[CallConfig, GroupCallConfig]]",
              "description": "Additional configuration for the call.",
              "source_config": "CALL_CONFIG_DESC",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method. exception pytgcalls.exceptions.NoActiveGroupCall\nYou cannot edit a group call that hasn't been initiated. exception ntgcalls.FFmpegError\nTo use Piped input stream, make sure you have FFmpeg installed. exception ntgcalls.ShellError\nError while executing the shell script. exception pytgcalls.exceptions.CallDeclined\nThe call was declined by the user.\nexception pytgcalls.exceptions.CallBusy\nWhen the user is already in a call.\nexception pytgcalls.exceptions.CallDiscarded\nThe call was discarded by the user while connecting.\nexception ntgcalls.TelegramServerError\nThis error occurs when the connection between Telegram and the WebRTC service fails.",
              "source_config": "BASE_MTPROTO",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Record"
  },
  "/PyTgCalls/Stream Methods/Resume.xml": {
    "title": "Resume",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows resuming the streaming file.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.resume(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.resume() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Resume"
  },
  "/PyTgCalls/Stream Methods/Time.xml": {
    "title": "Time",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows getting the played time of the stream.",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\nprint(\n    app.time(\n        -1001185324811,\n    )\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.time() -> int",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            },
            {
              "name": "direction -> Direction",
              "type": null,
              "description": " Stream direction for the stream.",
              "source_config": null,
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/Time"
  },
  "/PyTgCalls/Stream Methods/UnMute.xml": {
    "title": "UnMute",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "This method allows unmuting the userbot via MTProto APIs",
    "example": {
      "language": "python",
      "code": "from pytgcalls import Client\nfrom pytgcalls import idle\n...\n\napp = PyTgCalls(client)\napp.start()\n\n...  # Call API methods\n\napp.unmute(\n    -1001185324811,\n)\n\nidle()"
    },
    "details": {
      "signature": "PyTgCalls.unmute() -> bool",
      "sections": [
        {
          "title": "PARAMETERS",
          "items": [
            {
              "name": "chat_id",
              "type": "Union[int, str]",
              "description": "Can be direct id or a username",
              "source_config": "ARG_CHAT_ID",
              "value": null
            }
          ]
        },
        {
          "title": "RAISES",
          "items": [
            {
              "name": "",
              "type": null,
              "description": "exception pytgcalls.exceptions.NoMTProtoClient\nThis method can only be called with a valid MTProto client set.\nexception pytgcalls.exceptions.ClientNotStarted\nEnsure you have started the process with start() before calling this method.\nexception pytgcalls.exceptions.NotInCallError\nThis error occurs when attempting to execute an action on a call that you have not joined.",
              "source_config": "BASE_EXCEPTIONS",
              "value": null
            }
          ]
        }
      ]
    },
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Stream Methods/UnMute"
  },
  "/PyTgCalls/Using Filters.xml": {
    "title": "Using Filters",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        So far weve seen ",
    "example": {},
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Using Filters"
  },
  "/PyTgCalls/Using Handlers.xml": {
    "title": "Using Handlers",
    "lib": "PyTgCalls",
    "kind": "method",
    "description": "\n        Handlers are used to instruct PyTgCalls to execute a specific function when a certain event occurs.\n        For a much more convenient way to handle updates, you can use the ",
    "example": {
      "language": "python",
      "code": "from pytgcalls import PyTgCalls\nfrom pytgcalls.types import Update\nfrom pytgcalls import filters as call_filters\n...\n\nclient = # Here Your MTProto Client\napp = PyTgCalls(client)\n\nasync def handler(client: PyTgCalls, update: Update):\n    print(update)\n...\napp.add_handler(handler, call_filters.stream_end())\n..."
    },
    "details": {},
    "doc_url": "https://pytgcalls.github.io/PyTgCalls/Using Handlers"
  }
}